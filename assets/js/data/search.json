[
  
  {
    "title": "AMSI Evasion - Runtime DLL Load Interception",
    "url": "/posts/AMSI/",
    "categories": "Maldev",
    "tags": "AMSI",
    "date": "2025-10-26 00:00:00 +0200",
    "content": "Introduction  While exploring the .NET CLR, I’ve always been fascinated by the process of loading assemblies mapping entry points, inspecting methods and classes, and manipulating the loading context itself. In my journey in malware development, I used to craft heavily obfuscated and packed C# payloads. Statically, they evaded detection with ease no suspicious API calls, clean imports. But the moment they executed, AVs and EDRs lit up . That’s when I dove deep into runtime defense mechanisms a vast and brutal landscape. Today, I’m focusing on: AMSI (Antimalware Scan Interface).  What is AMSI  AMSI Antimalware Scan Interface is a Windows interface that allows applications (like PowerShell, WMI, JScript, VBScript, and the .NET runtime) to submit memory buffers such as scripts, in-memory assemblies, or dynamically compiled code to registered antivirus engines for scanning before execution. It operates at the user-mode API level via AmsiScanBuffer(), enabling real-time malware detection regardless of the source (file, stream, or memory).  So loading an assembly is not that easy anymore :D because PowerShell.Invoke(), .NET Assembly.Load(byte[]), Add-Type, trigger AMSI, and spawn amsi.dll directly in your process :).  Well, bypassing it is easy and not easy at the same time. Regardless of many techniques in the Red Team area, the EDRs and Detection systems are too fast to enhance their defenses and stay ahead of these techniques.    The Problem with Traditional AMSI Patching  A famous technique for bypassing AMSI is to patch it (locate AmsiScanBuffer() in the process address space and patch the return address so we can skip the jmp to AmsiScanBuffer(), or patch its arguments, so we can give it a null byte instead of our “Malicious Code”). But it’s very detected because of the suspicious sequence of the API calls used: VirtualProtect, WriteProcessMemory, GetProcAddress(\"AmsiScanBuffer\") also the YARA rules match known patterns like 48 31 C0 C3 (xor rax,rax; ret).    So I was searching for a method to “kill” the amsi.dll, or in other terms, not let it attach to my process; I found an article and a technique called BlindSide: BlindSide Documentation, it was what I was looking for!!  BlindSide Technique  Blindside sets a hardware breakpoint (DR0) on LdrLoadDll in a debugged child process, blocks all DLL loads after ntdll.dll, then copies the unhooked .text section into the target process to unhook EDR-instrumented syscalls.  Problems in BlindSide (HWBP)  Touching the debug registers is very flagged by EDRs and it’s well recorded by ETW.  As we can see in NtSetContextThread() code disassembled: EtwWrite function traces the usage of NtSetContextThread; (Source: Crowdstrike Investigations)       Blindside lets amsi.dll load, then unhooks ntdll (overkill), which can be flagged by the same YARA rules of patching…   and putting LdrLoadDll, or AmsiScanBuffer Address in Debug register is very flagged, because it is easy to be consulted by EDR.     Enhanced Method  So I tried to fix those in my technique by:     Stop amsi.dll before it loads  using a software breakpoint (0xCC) Documentation   No debug registers (DR0–DR7) → zero SetThreadContext(CONTEXT_DEBUG_REGISTERS)   No dummy process → direct debugging of target via `DEBUG_PROCESS   No .text unhooking → no memory copy, no PAGE_EXECUTE_READWRITE   ASLR-safe offset matching → LdrLoadDll located using local ntdll.dll (That’s was a real problem in blindside, not sure about hardcoded offset in the code, who knows what ASLR will lead to)   Trap Flag (TF) re-arms 0xCC → self-healing hook - 1-byte touch → minimal footprint, restored on non-target loads   How LdrLoadDll works ? How It Works (x64 Calling Convention) NTSTATUS LdrLoadDll(     PWCHAR         PathToFile,      // RCX (optional search path)     ULONG          Flags,           // RDX     PUNICODE_STRING ModuleFileName, // R8   DLL name (e.g., L\"amsi.dll\" in our case)     PHANDLE        ModuleHandle     // R9   Output: base address );   Called by LoadLibrary, CLR, PowerShell, etc.    Resolves path ==&gt; maps DLL ==&gt; runs DllMain.   If this fails ==&gt; DLL never loads.   2) Exploitation Strategy  Step-by-Step Process:                 Step       Action                       1       Launch target (e.g., powershell.exe) under DEBUG_PROCESS                 2       Wait for ntdll.dll to load → locate LdrLoadDll via offset matching                 3       Inject 0xCC (INT3) at LdrLoadDll entry → triggers EXCEPTION_BREAKPOINT                 4       On trap:  → Read R8 → remote UNICODE_STRING  → Read actual string → “amsi.dll”?  → Yes →     - Write 0 to *ModuleHandle (R9)     - Set RAX = STATUS_DLL_NOT_FOUND     - Jump to return address  → No → single-step to restore 0xCC                 5       Result: LdrLoadDll returns failure = amsi.dll never maps.           So the main idea is to turn LdrLoadDll into a firewall xD :D.  Let’s code our idea :) Implementation Details  1) Remote Memory R/W — Read/WriteProcessMemory + FlushInstructionCache for stealthy cross-process access.    static int read_target_memory(LPCVOID addr, void *buf, SIZE_T size) {     SIZE_T read = 0;     return ReadProcessMemory(g_process_handle, addr, buf, size, &amp;read) &amp;&amp; read == size; }  static int write_target_memory(LPVOID addr, const void *buf, SIZE_T size) {     SIZE_T written = 0;     return WriteProcessMemory(g_process_handle, addr, buf, size, &amp;written) &amp;&amp;            written == size &amp;&amp;            FlushInstructionCache(g_process_handle, addr, size); }   2)  1 BYTE MODIFICATION in LdrLoadDll :    static int install_interception_point(LPVOID func_addr, BYTE *backup) { BYTE current; BYTE int3 = 0xCC;  if (!read_target_memory(func_addr, ¤t, 1)) return 0; *backup = current; return modify_executable_memory(func_addr, &amp;int3, 1); }  3) If amsi.dll detected = Error and jmp : if (check_for_specific_module(module_name_buffer)) {     // Null out ModuleHandle (R9)     ULONGLONG null_handle = 0;     write_target_memory((LPVOID)thread_context.R9, &amp;null_handle, 8);      // Force failure     thread_context.Rax = STATUS_DLL_NOT_FOUND;  // 0xC0000135      // Jump to return address (bypass function body)     ULONGLONG ret_addr;     read_target_memory((LPCVOID)thread_context.Rsp, &amp;ret_addr, 8);     thread_context.Rsp += 8;     thread_context.Rip = ret_addr; }   4) Single-Step Re-arming (Trap Flag) static void prepare_single_step_execution(HANDLE thread, CONTEXT ctx, DWORD tid) {     ctx.EFlags |= 0x100;  // Set Trap Flag (TF)     SetThreadContext(thread, &amp;ctx);     g_awaiting_reactivation_id = tid;     CloseHandle(thread); }   !] To find LdrLoadDll?  To find LdrLoadDll, we will check for Offset matching when loading ntdll.dll;   HMODULE local_ntdll = GetModuleHandleA(\"ntdll.dll\"); FARPROC local_LdrLoadDll = GetProcAddress(local_ntdll, \"LdrLoadDll\"); uintptr_t offset = (uintptr_t)local_LdrLoadDll - (uintptr_t)local_ntdll;  g_intercept_function_addr = (BYTE*)g_target_module_base + offset;   For security considerations, I’ll share the conceptual approach code rather than complete code Let’s try if we can bypass AMSI :D.  TEST :)  I will test in Windows 10; with updated MDE :D. It bypassed static detection (It’s logical, we are not harmful :) but we can load what could be harmful).  Without Bypass :    With Bypass :    As you see in these two pictures; launching a normal PowerShell triggers &amp; loads amsi.dll. In our case, the amsi.dll is not welcomed :). We can’t write an \"Invoke-Mimikatz\" which is considered a malicious string by AMSI scan :). Let’s try a real test :D. Let’s try to load a .NET assembly using PowerShell, and for that we will load Rubeus (A tool used in red team to Kerberos abuse and exploitation). First, we will not write Rubeus to the disk because it will be detected and deleted :), and we want a fileless PowerShell one-liner :).  So; we can convert the bytes of Rubeus to base64 and invoke its entry point using: [System.Reflection.Assembly]::Load([System.Convert]::FromBase64String(\"BASE64\")).EntryPoint.Invoke($null, @(,[string[]]@()))  Let’s try with amsi bypass, and without amsi bypass :).  Loading Rubeus in memory failed; because of the AMSI:   After Byapssing AMSI :    That’s it for today; wait for coming blogs !! i still have lot of ideas to share with you."
  }
  
]


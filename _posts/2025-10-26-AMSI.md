---
title: Dive into AMSI BYPASS
date: 2025-10-26 
categories: [Maldev]
tags: [AMSI]
comments: false
---

## Introduction

While exploring the .NET CLR, I've always been fascinated by the process of loading assemblies mapping entry points, inspecting methods and classes, and manipulating the loading context itself. In my journey in malware development, I used to craft heavily obfuscated and packed C# payloads. Statically, they evaded detection with ease no suspicious API calls, clean imports. But the moment they executed, **AVs and EDRs lit up . That's when I dove deep into runtime defense mechanisms a vast and brutal landscape. Today, I'm focusing on: AMSI (Antimalware Scan Interface)**.

## What is AMSI

AMSI [Antimalware Scan Interface](https://learn.microsoft.com/fr-fr/windows/win32/amsi/antimalware-scan-interface-portal]) is a Windows interface that allows applications (like PowerShell, WMI, JScript, VBScript, and the .NET runtime) to submit memory buffers such as scripts, in-memory assemblies, or dynamically compiled code to registered antivirus engines for scanning **before execution**. It operates at the **user-mode API level** via `AmsiScanBuffer()`, enabling real-time malware detection regardless of the source (file, stream, or memory).

So loading an assembly is not that easy anymore :D because `PowerShell.Invoke()`, `.NET Assembly.Load(byte[])`, `Add-Type`, trigger AMSI, and spawn `amsi.dll` directly in your process :).

Well, bypassing it is easy and not easy at the same time. Regardless of many techniques in the Red Team area, the EDRs and Detection systems are too fast to enhance their defenses and stay ahead of these techniques.

![Logo](/assets/img/posts/amsi.jpg)

## The Problem with Traditional AMSI Patching

A famous technique for bypassing AMSI is to patch it (locate `AmsiScanBuffer()` in the process address space and patch the return address so we can skip the jmp to `AmsiScanBuffer()`, or patch its arguments, so we can give it a null byte instead of our "Malicious Code"). But it's very detected because of the suspicious sequence of the API calls used: `VirtualProtect`, `WriteProcessMemory`, `GetProcAddress("AmsiScanBuffer")` also the YARA rules match known patterns like `48 31 C0 C3 (xor rax,rax; ret)`.

![Logo](/assets/img/posts/amsiscanbuffer.png)

So I was searching for a method to "kill" the amsi.dll, or in other terms, not let it attach to my process; I found an article and a technique called BlindSide: [BlindSide Documentation](https://cymulate.com/blog/blindside-a-new-technique-for-edr-evasion-with-hardware-breakpoints/), it was what I was looking for!!

## BlindSide Technique

Blindside sets a hardware breakpoint (DR0) on LdrLoadDll in a debugged child process, blocks all DLL loads after `ntdll.dll`, then copies the unhooked .text section into the target process to unhook EDR-instrumented syscalls.

## Problems in BlindSide (HWBP)

 Touching the debug registers is very flagged by EDRs and it's well recorded by ETW. 
As we can see in `NtSetContextThread()` code disassembled:
`EtwWrite` function traces the usage of `NtSetContextThread`; (Source: Crowdstrike Investigations)

![Logo](/assets/img/posts/Etwi.png)

+ Blindside lets `amsi.dll` load, then unhooks ntdll (overkill), which can be flagged by the same YARA rules of patching...
+ and putting LdrLoadDll, or AmsiScanBuffer Address in Debug register is very flagged, because it is easy to be consulted by EDR.

![Logo](/assets/img/posts/debug_register.png)

##  **Enhanced Method**

So I tried to fix those in my technique by:

- Stop `amsi.dll` *before* it loads  using a software breakpoint (`0xCC`) [Documentation](https://www.ollydbg.de/Help/i_Breakpoints.htm)
- No debug registers (DR0–DR7) → zero `SetThreadContext(CONTEXT_DEBUG_REGISTERS)`
- No dummy process → direct debugging of target via `DEBUG_PROCESS
- No `.text` unhooking → no memory copy, no `PAGE_EXECUTE_READWRITE`
- ASLR-safe offset matching → `LdrLoadDll` located using local `ntdll.dll` (That's was a real problem in blindside, not sure about hardcoded offset in the code, who knows what ASLR will lead to)
- Trap Flag (TF) re-arms `0xCC` → self-healing hook - 1-byte touch → minimal footprint, restored on non-target loads

## How LdrLoadDll works ? 
 **How It Works (x64 Calling Convention)**
 ```cpp
NTSTATUS LdrLoadDll(
    PWCHAR         PathToFile,      // RCX (optional search path)
    ULONG          Flags,           // RDX
    PUNICODE_STRING ModuleFileName, // R8   DLL name (e.g., L"amsi.dll" in our case)
    PHANDLE        ModuleHandle     // R9   Output: base address
);
 ```

 Called by LoadLibrary, CLR, PowerShell, etc.
- Resolves path ==> maps DLL ==> runs DllMain.
- **If this fails ==> DLL never loads.**

### 2) Exploitation Strategy

**Step-by-Step Process:**

| Step | Action                                                                                                                                                                                                                                                                 |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | Launch target (e.g., powershell.exe) under DEBUG_PROCESS                                                                                                                                                                                                               |
| 2    | Wait for ntdll.dll to load → locate LdrLoadDll via offset matching                                                                                                                                                                                                     |
| 3    | Inject 0xCC (INT3) at LdrLoadDll entry → triggers EXCEPTION_BREAKPOINT                                                                                                                                                                                                 |
| 4    | On trap:  <br>→ Read R8 → remote UNICODE_STRING  <br>→ Read actual string → "amsi.dll"?  <br>→ **Yes** →  <br>   - Write 0 to *ModuleHandle (R9)  <br>   - Set RAX = STATUS_DLL_NOT_FOUND  <br>   - Jump to return address  <br>→ **No** → single-step to restore 0xCC |
| 5    | Result: LdrLoadDll returns failure = amsi.dll never maps.                                                                                                                                                                                                              |

So the main idea is to turn LdrLoadDll into a firewall xD :D.

Let's code our idea :) 
## Implementation Details

**1) Remote Memory R/W — Read/WriteProcessMemory + FlushInstructionCache for stealthy cross-process access.**
```cpp
   static int read_target_memory(LPCVOID addr, void *buf, SIZE_T size) {
    SIZE_T read = 0;
    return ReadProcessMemory(g_process_handle, addr, buf, size, &read) && read == size;
}
```
```cpp
static int write_target_memory(LPVOID addr, const void *buf, SIZE_T size) {
    SIZE_T written = 0;
    return WriteProcessMemory(g_process_handle, addr, buf, size, &written) &&
           written == size &&
           FlushInstructionCache(g_process_handle, addr, size);
}
```
 
**2)  1 BYTE MODIFICATION in LdrLoadDll :**
 ```cpp
   static int install_interception_point(LPVOID func_addr, BYTE *backup) { BYTE current; BYTE int3 = 0xCC;

if (!read_target_memory(func_addr, ¤t, 1)) return 0; *backup = current; return modify_executable_memory(func_addr, &int3, 1); }
```
**3) If amsi.dll detected = Error and jmp :**
```cpp
if (check_for_specific_module(module_name_buffer)) {
    // Null out ModuleHandle (R9)
    ULONGLONG null_handle = 0;
    write_target_memory((LPVOID)thread_context.R9, &null_handle, 8);

    // Force failure
    thread_context.Rax = STATUS_DLL_NOT_FOUND;  // 0xC0000135

    // Jump to return address (bypass function body)
    ULONGLONG ret_addr;
    read_target_memory((LPCVOID)thread_context.Rsp, &ret_addr, 8);
    thread_context.Rsp += 8;
    thread_context.Rip = ret_addr;
}
```

**4) Single-Step Re-arming (Trap Flag)**
```cpp
static void prepare_single_step_execution(HANDLE thread, CONTEXT ctx, DWORD tid) {
    ctx.EFlags |= 0x100;  // Set Trap Flag (TF)
    SetThreadContext(thread, &ctx);
    g_awaiting_reactivation_id = tid;
    CloseHandle(thread);
}
```

### !] To find LdrLoadDll?

```cpp
To find LdrLoadDll, we will check for Offset matching when loading ntdll.dll; 

HMODULE local_ntdll = GetModuleHandleA("ntdll.dll");
FARPROC local_LdrLoadDll = GetProcAddress(local_ntdll, "LdrLoadDll");
uintptr_t offset = (uintptr_t)local_LdrLoadDll - (uintptr_t)local_ntdll;

g_intercept_function_addr = (BYTE*)g_target_module_base + offset;
```

For security considerations, I'll share the conceptual approach code rather than complete code
Let's try if we can bypass AMSI :D.

## TEST :)

I will test in Windows 10; with updated MDE :D.
It bypassed static detection (It's logical, we are not harmful :) but we can load what could be harmful).

Without Bypass : 

![Logo](/assets/img/posts/without_bypass.png)

With Bypass : 


![Logo](/assets/img/posts/with_bypass.png)



As you see in these two pictures; launching a normal PowerShell triggers & loads amsi.dll. In our case, the amsi.dll is not welcomed :).
We can't write an `"Invoke-Mimikatz"` which is considered a malicious string by AMSI scan :).
Let's try a real test :D.
Let's try to load a .NET assembly using PowerShell, and for that we will load `Rubeus` (A tool used in red team to Kerberos abuse and exploitation).  
First, we will not write Rubeus to the disk because it will be detected and deleted :), and we want a fileless PowerShell one-liner :).

So; we can convert the bytes of Rubeus to base64 and invoke its entry point using:
```powershell
[System.Reflection.Assembly]::Load([System.Convert]::FromBase64String("BASE64")).EntryPoint.Invoke($null, @(,[string[]]@()))
```
Let's try with amsi bypass, and without amsi bypass :). 
Loading Rubeus in memory failed; because of the AMSI:
![Logo](/assets/img/posts/rubeus.png)

After Byapssing AMSI : 

![Logo](/assets/img/posts/rubeus_bypassed.png)

That's it for today; wait for coming blogs !! i still have lot of ideas to share with you.



